<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>VM Spec  </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
<table width=100%><tr>
<td><a href="VMSpecTOC.doc.html">Contents</a> | <a href="Instructions2.doc5.html">Prev</a> | <a href="Instructions2.doc7.html">Next</a> | <a href="VMSpecIX.fm.html">Index</a></td><td align=right><i><i>The Java<sup><font size=-2>TM</font></sup> Virtual Machine Specification</i></i></td>
</tr></table>


<hr><br>
 
<a href="Instructions2.doc.html">A</a>
<a href="Instructions2.doc1.html">B</a>
<a href="Instructions2.doc2.html">C</a>
<a href="Instructions2.doc3.html">D</a>
<a href="Instructions2.doc4.html">F</a>
<a href="Instructions2.doc5.html">G</a>
<a href="Instructions2.doc6.html">I</a>
<a href="Instructions2.doc7.html">J</a>
<a href="Instructions2.doc8.html">L</a>
<a href="Instructions2.doc9.html">M</a>
<a href="Instructions2.doc10.html">N</a>
<a href="Instructions2.doc11.html">P</a>
<a href="Instructions2.doc12.html">R</a>
<a href="Instructions2.doc13.html">S</a>
<a href="Instructions2.doc14.html">T</a>
<a href="Instructions2.doc15.html">W</a>

<a name="i2b"></a>
<hr><h2>i2b</h2>
<a name="i2b.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68328"></a>
Convert <code>int</code> to <code>byte</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68327"></a>
 <i>i2b</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="i2b.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68329"></a>
<i>i2b</i> = 145 (0x91)</blockquote><p>
<a name="i2b.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68330"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="i2b.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68331"></a>
The <i>value</i> on the top of the operand stack must be of type <code>int</code>. It is popped from the operand stack, truncated to a <code>byte</code>, then sign-extended to an <code>int</code> <i>result</i>. That <i>result</i> is pushed onto the operand stack.</blockquote><p>
<a name="i2b.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68332"></a>
The <i>i2b</i> instruction performs a narrowing primitive conversion <a href="Concepts.doc.html#26142">(&#167;2.6.3)</a>. It may lose information about the overall magnitude of <i>value</i>. The <i>result</i> may also not have the same sign as <i>value</i>.</blockquote><p>

<a name="i2c"></a>
<hr><h2>i2c</h2>
<a name="i2c.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68342"></a>
Convert <code>int</code> to <code>char</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68341"></a>
 <i>i2c</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="i2c.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68343"></a>
<i>i2c</i> = 146 (0x92)</blockquote><p>
<a name="i2c.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68344"></a>
..., <i>value</i><em> </em><img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="i2c.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68345"></a>
The <i>value</i> on the top of the operand stack must be of type <code>int</code>. It is popped from the operand stack, truncated to <code>char</code>, then zero-extended to an <code>int</code> <i>result</i>. That <i>result</i> is pushed onto the operand stack.</blockquote><p>
<a name="i2c.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68346"></a>
The <i>i2c</i> instruction performs a narrowing primitive conversion <a href="Concepts.doc.html#26142">(&#167;2.6.3)</a>. It may lose information about the overall magnitude of <i>value</i>. The <i>result</i> (which is always positive) may also not have the same sign as <i>value</i>.</blockquote><p>

<a name="i2d"></a>
<hr><h2>i2d</h2>
<a name="i2d.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68359"></a>
Convert <code>int</code> to <code>double</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68358"></a>
 <i>i2d</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="i2d.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68360"></a>
<i>i2d</i> = 135 (0x87)</blockquote><p>
<a name="i2d.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68361"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="i2d.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68362"></a>
The <i>value</i> on the top of the operand stack must be of type <code>int</code>. It is popped from the operand stack and converted to a <code>double</code> <i>result</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<a name="i2d.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68363"></a>
The <i>i2d</i> instruction performs a widening primitive conversion <a href="Concepts.doc.html#23435">(&#167;2.6.2)</a>. Because all values of type <code>int</code> are exactly representable by type <code>double</code>, the conversion is exact.</blockquote><p>

<a name="i2f"></a>
<hr><h2>i2f</h2>
<a name="i2f.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68379"></a>
Convert <code>int</code> to <code>float</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68378"></a>
 <i>i2f</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="i2f.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68380"></a>
<i>i2f</i> = 134 (0x86)</blockquote><p>
<a name="i2f.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68381"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="i2f.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68382"></a>
The <i>value</i> on the top of the operand stack must be of type <code>int</code>. It is popped from the operand stack and converted to the <code>float</code> <i>result</i> using IEEE 754 round to nearest mode. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<a name="i2f.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="344471"></a>
The <i>i2f</i> instruction performs a widening primitive conversion <a href="Concepts.doc.html#23435">(&#167;2.6.2)</a>, but may result in a loss of precision because values of type <code>float</code> have only 24 significand bits.</blockquote><p>

<a name="i2l"></a>
<hr><h2>i2l</h2>
<a name="i2l.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68393"></a>
Convert <code>int</code> to <code>long</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68392"></a>
 <i>i2l</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="i2l.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68394"></a>
<i>i2l</i> = 133 (0x85)</blockquote><p>
<a name="i2l.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68395"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="i2l.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68396"></a>
The <i>value</i> on the top of the operand stack must be of type <code>int</code>. It is popped from the operand stack and sign-extended to a <code>long</code> <i>result</i>. That <i>result</i> is pushed onto the operand stack.</blockquote><p>
<a name="i2l.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68397"></a>
The <i>i2l</i> instruction performs a widening primitive conversion <a href="Concepts.doc.html#23435">(&#167;2.6.2)</a>. Because all values of type <code>int</code> are exactly representable by type <code>long</code>, the conversion is exact.</blockquote><p>

<a name="i2s"></a>
<hr><h2>i2s</h2>
<a name="i2s.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68407"></a>
<p>Convert <code>int</code> to <code>short</code><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68406"></a>
 <i>i2s</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="i2s.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68408"></a>
<i>i2s</i> = 147 (0x93)</blockquote><p>
<a name="i2s.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68409"></a>
..., <i>value</i><em> </em><img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="i2s.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68410"></a>
The <i>value</i> on the top of the operand stack must be of type <code>int</code>. It is popped from the operand stack, truncated to a <code>short</code>, then sign-extended to an <code>int</code> <i>result</i>. That <i>result</i> is pushed onto the operand stack.</blockquote><p>
<a name="i2s.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68411"></a>
The <i>i2s</i> instruction performs a narrowing primitive conversion <a href="Concepts.doc.html#26142">(&#167;2.6.3)</a>. It may lose information about the overall magnitude of <i>value</i>. The <i>result</i> may also not have the same sign as <i>value</i>.</blockquote><p>

<a name="iadd"></a>
<hr><h2>iadd</h2>
<a name="iadd.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68421"></a>
Add <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68420"></a>
 <i>iadd</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="iadd.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68422"></a>
<i>iadd</i> = 96 (0x60)</blockquote><p>
<a name="iadd.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68423"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="iadd.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68424"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. The <code>int</code> <i>result</i> is <i>value1</i> + <i>value2</i>. The <i>result</i> is pushed onto the operand stack. </blockquote><p>
<blockquote><a name="68425"></a>
The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type <code>int</code>. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.</blockquote><p>
<blockquote><a name="448552"></a>
Despite the fact that overflow may occur, execution of an <i>iadd</i> instruction never throws a runtime exception.</blockquote><p>

<a name="iaload"></a>
<hr><h2>iaload</h2>
<a name="iaload.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68438"></a>
Load <code>int</code> from array<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68437"></a>
 <i>iaload</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="iaload.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68439"></a>
<i>iaload</i> = 46 (0x2e)</blockquote><p>
<a name="iaload.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68440"></a>
..., <i>arrayref</i>, <i>index</i> <img src="chars/arrwdbrt.gif"> ..., <i>value</i></blockquote><p>
<a name="iaload.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68441"></a>
The <i>arrayref</i> must be of type <code>reference</code> and must refer to an array whose components are of type <code>int</code>. The <i>index</i> must be of type <code>int</code>. Both <i>arrayref</i> and <i>index</i> are popped from the operand stack. The <code>int</code> <i>value</i> in the component of the array at <i>index</i> is retrieved and pushed onto the operand stack.</blockquote><p>
<a name="iaload.Runtime"></a>
<p><b>Runtime Exceptions</b><br>
<blockquote><a name="68443"></a>
If <i>arrayref</i><em> </em>is <code>null</code>, <i>iaload</i> throws a <code>NullPointerException</code>. </blockquote><p>
<blockquote><a name="68444"></a>
Otherwise, if <i>index</i> is not within the bounds of the array referenced by <i>arrayref</i>, the <i>iaload</i> instruction throws an <code>ArrayIndexOutOfBoundsException</code>.</blockquote><p>

<a name="iand"></a>
<hr><h2>iand</h2>
<a name="iand.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68454"></a>
Boolean AND <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68453"></a>
 <i>iand</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="iand.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68455"></a>
<i>iand</i> = 126 (0x7e)</blockquote><p>
<a name="iand.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68456"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="iand.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68457"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. They are popped from the operand stack. An <code>int</code> <i>result</i> is calculated by taking the bitwise AND (conjunction) of <i>value1</i> and <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>

<a name="iastore"></a>
<hr><h2>iastore</h2>
<a name="iastore.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68470"></a>
Store into <code>int</code> array<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68469"></a>
 <i>iastore</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="iastore.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68471"></a>
<i>iastore</i> = 79 (0x4f)</blockquote><p>
<a name="iastore.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68472"></a>
..., <i>arrayref</i>, <i>index</i>, <i>value</i> <img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="iastore.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68473"></a>
The <i>arrayref</i> must be of type <code>reference</code> and must refer to an array whose components are of type <code>int</code>. Both <i>index</i> and <i>value</i> must be of type <code>int</code>. The <i>arrayref</i>, <i>index</i>, and <i>value</i> are popped from the operand stack. The <code>int</code> <i>value</i> is stored as the component of the array indexed by <i>index</i>. </blockquote><p>
<a name="iastore.Runtime"></a>
<p><b>Runtime Exceptions</b><br>
<blockquote><a name="68475"></a>
If <i>arrayref</i><em> </em>is <code>null</code>, <i>iastore</i> throws a <code>NullPointerException</code>. </blockquote><p>
<blockquote><a name="68476"></a>
Otherwise, if <i>index</i> is not within the bounds of the array referenced by <i>arrayref</i>, the <i>iastore</i> instruction throws an <code>ArrayIndexOutOfBoundsException</code>.</blockquote><p>

<a name="iconst_i"></a>
<hr><h2>iconst_&lt;i&gt;</h2>
<a name="iconst_i.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68483"></a>
Push <code>int</code> constant<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68482"></a>
 <i>iconst_&lt;i&gt;</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="iconst_i.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68484"></a>
<i>iconst_m1</i> = 2 (0x2) <i>iconst_0</i> = 3 (0x3) <i>iconst_1</i> = 4 (0x4) <i>iconst_2</i> = 5 (0x5) <i>iconst_3</i> = 6 (0x6) <i>iconst_4</i> = 7 (0x7) <i>iconst_5</i> = 8 (0x8)</blockquote><p>
<a name="iconst_i.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68485"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>&lt;i&gt;</i></blockquote><p>
<a name="iconst_i.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68486"></a>
Push the <code>int</code> constant <i>&lt;i&gt;</i> (-<i>1</i>, <i>0</i>, <i>1</i>, <i>2</i>, <i>3</i>, <i>4</i> or <i>5</i>) onto the operand stack. </blockquote><p>
<a name="iconst_i.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68487"></a>
Each of this family of instructions is equivalent to <i>bipush</i> <i>&lt;i&gt;</i> for the respective value of <i>&lt;i&gt;</i>, except that the operand <i>&lt;i&gt;</i> is implicit.</blockquote><p>

<a name="idiv"></a>
<hr><h2>idiv</h2>
<a name="idiv.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68497"></a>
Divide <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68496"></a>
 <i>idiv</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="idiv.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68498"></a>
<i>idiv</i> = 108 (0x6c)</blockquote><p>
<a name="idiv.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68499"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="idiv.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68500"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. The <code>int</code> <i>result</i> is the value of the Java programming language expression <i>value1</i> / <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<blockquote><a name="68501"></a>
An <code>int</code> division rounds towards 0; that is, the quotient produced for <code>int</code> values in <i>n</i>/<i>d</i> is an <code>int</code> value <i>q</i> whose magnitude is as large as possible while satisfying <img src="Instructions2.doc.anc6.gif">. Moreover, <i>q </i>is positive when <img src="Instructions2.doc.anc7.gif">  and <i>n</i> and <i>d</i> have the same sign, but <i>q</i> is negative when <img src="Instructions2.doc.anc8.gif">
and <i>n</i> and <i>d </i>have opposite signs. </blockquote><p>
<blockquote><a name="68511"></a>
There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for the <code>int</code> type, and the divisor is -<i>1</i>, then overflow occurs, and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case. </blockquote><p>
<a name="idiv.Runtime"></a>
<p><b>Runtime Exception</b><br>
<blockquote><a name="68513"></a>
If the value of the divisor in an <code>int</code> division is 0, <i>idiv</i> throws an <code>ArithmeticException</code>.</blockquote><p>

<a name="if_acmpcond"></a>
<hr><h2>if_acmp&lt;cond&gt;</h2>
<a name="if_acmpcond.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="339213"></a>
&#32;Branch if <code>reference</code> comparison succeeds<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="339202"></a>
 <i>if_acmp&lt;cond&gt;</i>
<td><a name="339204"></a>
 

<tr><td><a name="339206"></a>
 <i>branchbyte1</i>
<td><a name="339208"></a>
 

<tr><td><a name="339210"></a>
 <i>branchbyte2</i>
<td><a name="339212"></a>
 

</Table><br></blockquote><p>
<a name="if_acmpcond.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68525"></a>
<i>if_acmpeq</i> = 165 (0xa5) <i>if_acmpne</i> = 166 (0xa6)</blockquote><p>
<a name="if_acmpcond.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68526"></a>
..., <i>value1</i>, <i>value2</i> <img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="if_acmpcond.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68527"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>reference</code>. They are both popped from the operand stack and compared. The results of the comparison are as follows:</blockquote><p>
<ul><li><i>eq</i> 	succeeds if and only if <i>value1</i> = <i>value2</i>
<li><i>ne</i> 	succeeds if and only if <i>value1</i> <img src="chars/notequal.gif"> <i>value2</i>
</ul><blockquote><a name="68530"></a>
If <em>the comparison succeeds, the unsigned </em><i>branchbyte1</i> and <i>branchbyte2</i> are used to construct a signed 16-bit offset, where the offset is calculated to be (<i>branchbyte1</i> << 8) | <i>branchbyte2</i>. Execution then proceeds at that offset from the address of the opcode of this <i>if_acmp&lt;cond&gt;</i> instruction. The target address must be that of an opcode of an instruction within the method that contains this <i>if_acmp&lt;cond&gt;</i> instruction.</blockquote><p>
<blockquote><a name="68531"></a>
Otherwise, if the comparison fails, execution proceeds at the address of the instruction following this <i>if_acmp&lt;cond&gt;</i> instruction.</blockquote><p>

<a name="if_icmpcond"></a>
<hr><h2>if_icmp&lt;cond&gt;</h2>
<a name="if_icmpcond.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68548"></a>
<i></i>Branch if <code>int</code> comparison succeeds<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68543"></a>
 <i>if_icmp&lt;cond&gt;</i>
<td><a name="87568"></a>
 

<tr><td><a name="68545"></a>
 <i>branchbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="68547"></a>
 <i>branchbyte2</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="if_icmpcond.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="166925"></a>
<i>if_icmpeq</i>	=	159 (0x9f) <i>if_icmpne</i>	=	160 (0xa0) <i>if_icmplt</i> 	= 	161 (0xa1) <i>if_icmpge</i>	=	162 (0xa2) <i>if_icmpgt</i>	=	163 (0xa3) <i>if_icmple</i>	=	164 (0xa4)</blockquote><p>
<a name="if_icmpcond.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68550"></a>
..., <i>value1</i>, <i>value2</i> <img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="if_icmpcond.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68551"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparison are as follows:</blockquote><p>
<ul><li><i>eq</i> 	succeeds if and only if <i>value1</i> = <i>value2</i>
<li><i>ne</i> 	succeeds if and only if <i>value1</i> <img src="chars/notequal.gif"> <i>value2</i>
<li><i>lt </i>	succeeds if and only if <i>value1</i> < <i>value2</i>
<li><i>le</i> 	succeeds if and only if <i>value1</i> <img src="chars/lt_equal.gif"> <i>value2</i>
<li><i>gt</i> 	succeeds if and only if <i>value1</i> > <i>value2</i>
<li><i>ge</i> 	succeeds if and only if <i>value1</i> <img src="chars/gtequal.gif"> <i>value2</i>
</ul>
<blockquote><a name="68558"></a>
If <em>the comparison succeeds, the unsigned </em><i>branchbyte1</i> and <i>branchbyte2</i> are used to construct a signed 16-bit offset, where the offset is calculated to be (<i>branchbyte1</i> << 8) | <i>branchbyte2</i>. Execution then proceeds at that offset from the address of the opcode of this <i>if_icmp&lt;cond&gt;</i> instruction. The target address must be that of an opcode of an instruction within the method that contains this <i>if_icmp&lt;cond&gt;</i> instruction.</blockquote><p>
<blockquote><a name="68559"></a>
Otherwise, execution proceeds at the address of the instruction following this <i>if_icmp&lt;cond&gt;</i> instruction. </blockquote><p>

<a name="ifcond"></a>
<hr><h2>if&lt;cond&gt;</h2>
<a name="ifcond.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68570"></a>
Branch if <i></i><code>int</code> comparison with zero succeeds<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68565"></a>
 <i>if&lt;cond&gt;</i>
<td><a name="87568"></a>
 

<tr><td><a name="68567"></a>
 <i>branchbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="68569"></a>
 <i>branchbyte2</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="ifcond.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68571"></a>
<i>ifeq	</i>=	153 (0x99) <i>ifne</i>	=	154 (0x9a) <i>iflt</i>	=	155 (0x9b) <i>ifge</i>	=	156 (0x9c) <i>ifgt</i>	=	157 (0x9d) <i>ifle</i>	=	158 (0x9e)</blockquote><p>
<a name="ifcond.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68572"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="ifcond.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68573"></a>
The <i>value</i> must be of type <code>int</code>. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:</blockquote><p>
<ul><li><i>eq</i> 	succeeds if and only if <i>value</i> = 0
<li><i>ne</i> 	succeeds if and only if <i>value</i> <img src="chars/notequal.gif"> 0
<li><i>lt</i> 	succeeds if and only if <i>value</i> < 0
<li><i>le</i> 	succeeds if and only if <i>value</i> <img src="chars/lt_equal.gif"> 0
<li><i>gt</i> 	succeeds if and only if <i>value</i> > 0
<li><i>ge</i> 	succeeds if and only if <i>value</i> <img src="chars/gtequal.gif"> 0
</ul>
<blockquote><a name="68580"></a>
If the comparison succeeds, <em>the unsigned</em> <i>branchbyte1</i> and <i>branchbyte2</i> are used to construct a signed 16-bit offset, where the offset is calculated to be (<i>branchbyte1</i> << 8) | <i>branchbyte2</i>. Execution then proceeds at that offset from the address of the opcode of this <i>if&lt;cond&gt;</i> instruction. The target address must be that of an opcode of an instruction within the method that contains this <i>if&lt;cond&gt;</i> instruction.</blockquote><p>
<blockquote><a name="68581"></a>
Otherwise, execution proceeds at the address of the instruction following this <i>if&lt;cond&gt;</i> instruction.</blockquote><p>

<a name="ifnonnull"></a>
<hr><h2>ifnonnull</h2>
<a name="ifnonnull.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68592"></a>
Branch if <code>reference</code> not <code>null</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68587"></a>
 <i>ifnonnull</i>
<td><a name="87568"></a>
 

<tr><td><a name="68589"></a>
 <i>branchbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="68591"></a>
 <i>branchbyte2</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="ifnonnull.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68593"></a>
<i>ifnonnull</i> = 199 (0xc7)</blockquote><p>
<a name="ifnonnull.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68594"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="ifnonnull.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="504905"></a>
The <i>value</i> must be of type <code>reference</code>. It is popped from the operand stack. If <i>value</i> is not <code>null</code>, <em>the unsigned</em> <i>branchbyte1</i> and <i>branchbyte2</i> are used to construct a signed 16-bit offset, where the offset is calculated to be (<i>branchbyte1</i> << 8) | <i>branchbyte2</i>. Execution then proceeds at that offset from the address of the opcode of this <i>ifnonnull</i> instruction. The target address must be that of an opcode of an instruction within the method that contains this <i>ifnonnull</i> instruction.</blockquote><p>
<blockquote><a name="68596"></a>
Otherwise, execution proceeds at the address of the instruction following this <i>ifnonnull</i> instruction.</blockquote><p>

<a name="ifnull"></a>
<hr><h2>ifnull</h2>
<a name="ifnull.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68607"></a>
Branch if <code>reference</code> is <code>null</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68602"></a>
 <i>ifnull</i>
<td><a name="87568"></a>
 

<tr><td><a name="68604"></a>
 <i>branchbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="68606"></a>
 <i>branchbyte2</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="ifnull.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68608"></a>
<i>ifnull</i> = 198 (0xc6)</blockquote><p>
<a name="ifnull.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68609"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="ifnull.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68610"></a>
The <i>value</i> must of type <code>reference</code>. It is popped from the operand stack. If <i>value</i> is <code>null</code>, <em>the unsigned</em> <i>branchbyte1</i> and <i>branchbyte2</i> are used to construct a signed 16-bit offset, where the offset is calculated to be (<i>branchbyte1</i> << 8) | <i>branchbyte2</i>. Execution then proceeds at that offset from the address of the opcode of this <i>ifnull</i> instruction. The target address must be that of an opcode of an instruction within the method that contains this <i>ifnull</i> instruction.</blockquote><p>
<blockquote><a name="68611"></a>
Otherwise, execution proceeds at the address of the instruction following this <i>ifnull</i> instruction.</blockquote><p>

<a name="iinc"></a>
<hr><h2>iinc</h2>
<a name="iinc.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68622"></a>
Increment local variable by constant<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68617"></a>
 <i>iinc</i>
<td><a name="87568"></a>
 

<tr><td><a name="68619"></a>
 <i>index</i>
<td><a name="87568"></a>
 

<tr><td><a name="68621"></a>
 <i>const</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="iinc.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68623"></a>
<i>iinc</i> = 132 (0x84)</blockquote><p>
<a name="iinc.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68624"></a>
No change</blockquote><p>
<a name="iinc.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68625"></a>
The <i>index</i> is an unsigned byte that must be an index into the local variable array of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The <i>const</i> is an immediate signed byte. The local variable at <i>index</i> must contain an <code>int</code>. The value <i>const</i> is first sign-extended to an <code>int</code>, and then the local variable at <i>index</i> is incremented by that amount.</blockquote><p>
<a name="iinc.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68629"></a>
The <i>iinc</i> opcode can be used in conjunction with the <i>wide</i> instruction to access a local variable using a two-byte unsigned index and to increment it by a two-byte immediate value.</blockquote><p>
<blockquote><a name="68630"></a>
</blockquote><p>

<a name="iload"></a>
<hr><h2>iload</h2>
<a name="iload.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="339438"></a>
Load <code>int</code> from local variable<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="339431"></a>
 <i>iload</i>
<td><a name="339433"></a>
 

<tr><td><a name="339435"></a>
 <i>index</i>
<td><a name="339437"></a>
 

</Table><br></blockquote><p>
<a name="iload.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68640"></a>
<i>iload</i> = 21 (0x15)</blockquote><p>
<a name="iload.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68641"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>value</i></blockquote><p>
<a name="iload.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68642"></a>
The <i>index</i> is an unsigned byte that must be an index into the local variable array of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The local variable at <i>index</i> must contain an <code>int</code>. The <i>value</i> of the local variable at <i>index </i>is pushed onto the operand stack.</blockquote><p>
<a name="iload.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68646"></a>
The <i>iload</i> opcode can be used in conjunction with the <i>wide</i> instruction to access a local variable using a two-byte unsigned index.</blockquote><p>

<a name="iload_n"></a>
<hr><h2>iload_&lt;n&gt;</h2>
<a name="iload_n.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68656"></a>
Load <code>int</code> from local variable<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68655"></a>
 <i>iload_&lt;n&gt;</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="iload_n.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68657"></a>
<i>iload_0</i> = 26 (0x1a) <i>iload_1</i> = 27 (0x1b) <i>iload_2</i> = 28 (0x1c) <i>iload_3</i> = 29 (0x1d)</blockquote><p>
<a name="iload_n.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68658"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>value</i></blockquote><p>
<a name="iload_n.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68659"></a>
The <i>&lt;n&gt;</i> must be an index into the local variable array of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The local variable at <i>&lt;n&gt;</i> must contain an <code>int</code>. The <i>value</i> of the local variable at <i>&lt;n&gt;</i> is pushed onto the operand stack.</blockquote><p>
<a name="iload_n.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68663"></a>
Each of the <i>iload_&lt;n&gt;</i> instructions is the same as <i>iload</i> with an <i>index</i> of <i>&lt;n&gt;</i>, except that the operand <i>&lt;n&gt;</i> is implicit.</blockquote><p>

<a name="imul"></a>
<hr><h2>imul</h2>
<a name="imul.Operation"></a>
<p><b>Operation</b><br>
<a name="68676"></a><blockquote>
 Multiply <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68675"></a>
 <i>imul</i>
<td><a name="87568"></a>
 

</Table><br><p>
<a name="imul.Forms"></a>
</blockquote>
<p><b>Forms</b><br>
<blockquote><a name="68677"></a>
<i>imul</i> = 104 (0x68)</blockquote><p>
<a name="imul.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68678"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="imul.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68679"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. The <code>int</code> <i>result</i> is <i>value1</i> * <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<blockquote><a name="448651"></a>
The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type <code>int</code>. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.</blockquote><p>
<blockquote><a name="448652"></a>
Despite the fact that overflow may occur, execution of an <i>imul</i> instruction never throws a runtime exception.</blockquote><p>
<blockquote><a name="448649"></a>
</blockquote><p>

<a name="ineg"></a>
<hr><h2>ineg</h2>
<a name="ineg.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68687"></a>
Negate <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68686"></a>
 <i>ineg</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="ineg.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68688"></a>
<i>ineg</i><em> </em>= 116 (0x74)</blockquote><p>
<a name="ineg.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68689"></a>
..., <i>value</i><em> </em><img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="ineg.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68690"></a>
The <i>value</i> must be of type <code>int</code>. It is popped from the operand stack. The <code>int</code> <i>result</i> is the arithmetic negation of <i>value</i>, -<i>value</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<blockquote><a name="68691"></a>
For <code>int</code> values, negation is the same as subtraction from zero. Because the Java virtual machine uses two's-complement representation for integers and the range of two's-complement values is not symmetric, the negation of the maximum negative <code>int</code> results in that same maximum negative number. Despite the fact that overflow has occurred, no exception is thrown. </blockquote><p>
<blockquote><a name="68692"></a>
For all <code>int</code> values <code>x</code>, -<code>x</code> equals (~<code>x</code>) + <code>1</code>.</blockquote><p>

<a name="instanceof"></a>
<hr><h2>instanceof</h2>
<a name="instanceof.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68727"></a>
<p>Determine if object is of given type<Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68722"></a>
 <i>instanceof</i>
<td><a name="87568"></a>
 

<tr><td><a name="68724"></a>
 <i>indexbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="68726"></a>
 <i>indexbyte2</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="instanceof.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68728"></a>
<i>instanceof</i> = 193 (0xc1)</blockquote><p>
<a name="instanceof.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68729"></a>
..., <i>objectref</i><em> </em><img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="instanceof.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68730"></a>
The <i>objectref</i>, which must be of type <code>reference</code>, is popped from the operand stack. The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the runtime constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The runtime constant pool item at the index must be a symbolic reference to a class, array, or interface type. The named class, array, or interface type is resolved <a href="ConstantPool.doc.html#71636">(&#167;5.4.3.1)</a>.</blockquote><p>
<blockquote><a name="140275"></a>
If <i>objectref</i> is not <code>null</code> and is an instance of the resolved class or array or implements the resolved interface, the <i>instanceof</i> instruction pushes an <code>int</code> <i>result</i> of <i>1</i> as an int on the operand stack. Otherwise, it pushes an <code>int</code> <i>result</i> of <i>0</i>.</blockquote><p>
<blockquote><a name="68740"></a>
The following rules are used to determine whether an <i>objectref</i> that is not <code>null</code> is an instance of the resolved type: If S is the class of the object referred to by <i>objectref</i> and T is the resolved class, array, or interface type, <i>instanceof</i> determines whether <i>objectref</i> is an instance of T as follows:</blockquote><p>
<ul><li>If S is an ordinary (nonarray) class, then:<p>
<ul>
<li>If T is a class type, then S must be the same class <a href="Concepts.doc.html#20389">(&#167;2.8.1)</a> as  T or a subclass of T.<p>
<li>If T is an interface type, then S must implement <a href="Concepts.doc.html#16432">(&#167;2.13)</a> interface T.
</ul></ul>
<ul><li>If S is an interface type, then:<p>
<ul>
<li>If T is a class type, then T must be <code>Object</code> <a href="Concepts.doc.html#27433">(&#167;2.4.7)</a>.<p>
<li>If T is an interface type, then T must be the same interface as  S, or a superinterface of S <a href="Concepts.doc.html#20603">(&#167;2.13.2)</a>.<p>
</ul><li>If S is a class representing the array type SC<code>[]</code>, that is, an array  of components of type SC, then:<p>
<ul>
<li>If T is a class type, then T must be <code>Object</code> <a href="Concepts.doc.html#27433">(&#167;2.4.7)</a>.<p>
<li>If T is an array type TC<code>[]</code>, that is, an array of components of type TC, then one of the following must be true:<p>
<ul>
<li>TC and SC are the same primitive type <a href="Concepts.doc.html#19511">(&#167;2.4.1)</a>.<p>
<li>TC and SC are reference types <a href="Concepts.doc.html#29375">(&#167;2.4.6)</a>, and type SC can be cast to TC by these runtime rules. <p>
</ul>
<li>If T is an interface type, T must be one of the interfaces implemented by arrays <a href="Concepts.doc.html#16446">(&#167;2.15)</a>. 
</ul></ul><a name="instanceof.Linking"></a>
<p><b>Linking Exceptions</b><br>
<blockquote><a name="115905"></a>
During resolution of symbolic reference to the class, array, or interface type, any of the exceptions documented in <a href="ConstantPool.doc.html#71636">Section 5.4.3.1</a> can be thrown.</blockquote><p>
<a name="instanceof.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68766"></a>
The <i>instanceof</i> instruction is very similar to the <i>checkcast</i> instruction. It differs in its treatment of <code>null</code>, its behavior when its test fails (<i>checkcast</i> throws an exception, <i>instanceof</i> pushes a result code), and its effect on the operand stack.</blockquote><p>
<blockquote><a name="68767"></a>
</blockquote><p>

<a name="invokeinterface"></a>
<hr><h2>invokeinterface</h2>
<a name="invokeinterface.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68788"></a>
Invoke interface method<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68779"></a>
 <i>invokeinterface</i>
<td><a name="87568"></a>
 

<tr><td><a name="68781"></a>
 <i>indexbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="68783"></a>
 <i>indexbyte2</i>
<td><a name="87568"></a>
 

<tr><td><a name="68785"></a>
 <i>count</i>
<td><a name="87568"></a>
 

<tr><td><a name="68787"></a>
 <i>0</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="invokeinterface.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68789"></a>
<i>invokeinterface</i> = 185 (0xb9)</blockquote><p>
<a name="invokeinterface.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68790"></a>
...<em>, </em><i>objectref</i><em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="invokeinterface.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="285957"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the runtime constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The runtime constant pool item at that index must be a symbolic reference to an interface method <a href="ConstantPool.doc.html#73272">(&#167;5.1)</a>, which gives the name and descriptor <a href="ClassFile.doc.html#7035">(&#167;4.3.3)</a> of the interface method as well as a symbolic reference to the interface in which the interface method is to be found. The named interface method is resolved <a href="ConstantPool.doc.html#71722">(&#167;5.4.3.4)</a>. The interface method must not be an instance initialization method <a href="Overview.doc.html#12174">(&#167;3.9)</a> or the class or interface initialization method <a href="Overview.doc.html#12174">(&#167;3.9)</a>.</blockquote><p>
<blockquote><a name="395205"></a>
The <i>count</i> operand is an unsigned byte that must not be zero. The <i>objectref</i> must be of type <code>reference</code> and must be followed on the operand stack by <i>nargs</i> argument values, where the number, type, and order of the values must be consistent with the descriptor of the resolved interface method. The value of the fourth operand byte must always be zero.</blockquote><p>
<blockquote><a name="316034"></a>
Let C<em> </em>be the class of <em>objectref</em>. The actual method to be invoked is selected by the following lookup procedure:</blockquote><p>

<ul><li>If C contains a declaration for an instance method with the same name and descriptor as the resolved method, then this is the method to be invoked, and the lookup procedure terminates.<p>
<li>Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C; the method to be invoked is the result of the recursive invocation of this lookup procedure.<p>
<li>Otherwise, an <code>AbstractMethodError</code> is raised.
</ul><blockquote><a name="187953"></a>
If the method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is acquired or reentered.</blockquote><p>
<blockquote><a name="391024"></a>
If the method is not <code>native</code>, the <i>nargs </i>argument values and <i>objectref</i> are popped from the operand stack. A new frame is created on the Java virtual machine stack for the method being invoked. The <i>objectref</i> and the argument values are consecutively made the values of local variables of the new frame, with <i>objectref</i> in local variable <i>0</i>, <i>arg1</i> in local variable <i>1</i> (or, if <i>arg1</i> is of type <code>long</code> or <code>double</code>, in local variables <i>1</i> and <i>2</i>), and so on. Any argument value that is of a floating-point type undergoes value set conversion <a href="Overview.doc.html#33120">(&#167;3.8.3)</a> prior to being stored in a local variable. The new frame is then made current, and the Java virtual machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.</blockquote><p>
<blockquote><a name="210740"></a>
If the method is <code>native</code> and the platform-dependent code that implements it has not yet been bound <a href="ConstantPool.doc.html#74727">(&#167;5.6)</a> into the Java virtual machine, that is done. The <i>nargs</i> argument values and <i>objectref</i> are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion <a href="Overview.doc.html#33120">(&#167;3.8.3)</a> prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns:</blockquote><p>

<ul><li>If the <code>native</code> method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is released or exited as if by execution of a <i>monitorexit</i> instruction.<p>
<li>If the <code>native</code> method returns a value, the return value of the  platform-dependent code is converted in an implementation-dependent way to the return type of the <code>native</code> method and pushed onto the operand stack.
</ul><a name="invokeinterface.Linking"></a>
<p><b>Linking Exceptions</b><br>
<blockquote><a name="230485"></a>
During resolution of the symbolic reference to the interface method, any of the exceptions documented in <a href="ConstantPool.doc.html#71722">&#167;5.4.3.4</a> can be thrown.</blockquote><p>
<a name="invokeinterface.Runtime"></a>
<p><b>Runtime Exceptions</b><br>
<blockquote><a name="228552"></a>
Otherwise, if <i>objectref</i> is <code>null</code>, the <i>invokeinterface</i> instruction throws a <code>NullPointerException</code>. </blockquote><p>
<blockquote><a name="177889"></a>
Otherwise, if the class of <i>objectref</i> does not implement the resolved interface, <i>invokeinterface</i> throws an <code>IncompatibleClassChangeError</code>.</blockquote><p>
<blockquote><a name="177883"></a>
Otherwise, if no method matching the resolved name and descriptor is selected, <i>invokeinterface</i> throws an <code>AbstractMethodError</code>.</blockquote><p>
<blockquote><a name="475783"></a>
Otherwise, if the selected method is not <code>public</code>, <i>invokeinterface</i> throws an <code>IllegalAccessError</code>. </blockquote><p>
<blockquote><a name="475784"></a>
Otherwise, if the selected method is <code>abstract</code>, <i>invokeinterface</i> throws an <code>AbstractMethodError</code>.</blockquote><p>
<blockquote><a name="496559"></a>
Otherwise, if the selected method is <code>native</code> and the code that implements the method cannot be bound, <i>invokeinterface</i> throws an <code>UnsatisfiedLinkError</code>.</blockquote><p>

<a name="invokeinterface.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="403926"></a>
The <i>count</i> operand of the <i>invokeinterface</i> instruction records a measure of the number of argument values, where an argument value of type <code>long</code> or type <code>double</code> contributes two units to the <i>count</i> value and an argument of any other type contributes one unit. This information can also be derived from the descriptor of the selected method. The redundancy is historical. </blockquote><p>
<blockquote><a name="264762"></a>
The fourth operand byte exists to reserve space for an additional operand used in certain of Sun's implementations, which replace the <i>invokeinterface</i> instruction by a specialized pseudo-instruction at run time. It must be retained for backwards compatibility.</blockquote><p>
<blockquote><a name="448033"></a>
The <i>nargs</i> argument values and <i>objectref</i> are not one-to-one with the first <i>nargs</i> + <i>1</i> local variables. Argument values of types <code>long</code> and <code>double</code> must be stored in two consecutive local variables, thus more than <i>nargs</i> local variables may be required to pass <i>nargs</i> argument values to the invoked method.</blockquote><p>
<blockquote><a name="448030"></a>
</blockquote><p>

<a name="invokespecial"></a>
<hr><h2>invokespecial</h2>
<a name="invokespecial.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68833"></a>
Invoke<strong></strong> instance method; special handling for superclass, private, and instance initialization method invocations<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68838"></a>
 <i>invokespecial</i>
<td><a name="87568"></a>
 

<tr><td><a name="68840"></a>
 <i>indexbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="68842"></a>
 <i>indexbyte2</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="invokespecial.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68843"></a>
<i>invokespecial</i> = 183 (0xb7)</blockquote><p>
<a name="invokespecial.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68844"></a>
...<em>, </em><i>objectref</i><em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="invokespecial.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="278683"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the runtime constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The runtime constant pool item at that index must be a symbolic reference to a method <a href="ConstantPool.doc.html#73272">(&#167;5.1)</a>, which gives the name and descriptor <a href="ClassFile.doc.html#7035">(&#167;4.3.3)</a> of the method as well as a symbolic reference to the class in which the method is to be found. The named method is resolved <a href="ConstantPool.doc.html#86899">(&#167;5.4.3.3)</a>. Finally, if the resolved method is <code>protected</code> <a href="ClassFile.doc.html#1513">(&#167;4.6)</a>, and it is either a member of the current class or a member of a superclass of the current class, then the class of <i>objectref</i> must be either the current class or a subclass of the current class.</blockquote><p>
<blockquote><a name="437176"></a>
Next, the resolved method is selected for invocation unless all of the following conditions are true:</blockquote><p>
<ul><li>The <code>ACC_SUPER</code> flag (see <a href="ClassFile.doc.html#75734">Table 4.1, "Class access and property modifiers"</a>) is set for the current class.<p>
<li>The class of the resolved method is a superclass of the current class.<p>
<li>The resolved method is not an instance initialization method <a href="Overview.doc.html#12174">(&#167;3.9)</a>.
</ul>
<blockquote><a name="280879"></a>
If the above conditions are true, the actual method to be invoked is selected by the following lookup procedure. Let C<em> </em>be the direct superclass of the current class:</blockquote><p>
<ul><li>If C contains a declaration for an instance method with the same name and descriptor as the resolved method, then this method will be invoked. The lookup procedure terminates.<p>
<li>Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C. The method to be invoked is the result of the recursive invocation of this lookup procedure.<p>
<li>Otherwise, an <code>AbstractMethodError</code> is raised.
</ul><blockquote><a name="68873"></a>
The <i>objectref</i> must be of type <code>reference</code> and must be followed on the operand stack by <i>nargs</i> argument values, where the number, type, and order of the values must be consistent with the descriptor of the selected instance method.</blockquote><p>
<blockquote><a name="138167"></a>
If the method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is acquired or reentered.</blockquote><p>
<blockquote><a name="236993"></a>
If the method is not <code>native</code>, the <i>nargs</i> argument values and <i>objectref</i> are popped from the operand stack. A new frame is created on the Java virtual machine stack for the method being invoked. The <i>objectref</i> and the argument values are consecutively made the values of local variables of the new frame, with <i>objectref</i> in local variable <i>0</i>, <i>arg1</i> in local variable <i>1</i> (or, if <i>arg1</i> is of type <code>long</code> or <code>double</code>, in local variables <i>1</i> and <i>2</i>), and so on. Any argument value that is of a floating-point type undergoes value set conversion <a href="Overview.doc.html#33120">(&#167;3.8.3)</a> prior to being stored in a local variable. The new frame is then made current, and the Java virtual machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.</blockquote><p>
<blockquote><a name="236991"></a>
</blockquote><p>

<blockquote><a name="205637"></a>
If the method is <code>native</code> and the platform-dependent code that implements it has not yet been bound <a href="ConstantPool.doc.html#74727">(&#167;5.6)</a> into the Java virtual machine, that is done. The <i>nargs</i> argument values and <i>objectref</i> are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion <a href="Overview.doc.html#33120">(&#167;3.8.3)</a> prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns, the following take place:</blockquote><p>
<ul><li>If the <code>native</code> method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is released or exited as if by execution of a <i>monitorexit</i> instruction. <p>
<li>If the <code>native</code> method returns a value, the return value of the  platform-dependent code is converted in an implementation-dependent way to the return type of the <code>native</code> method and pushed onto the operand stack.
</ul><a name="invokespecial.Linking"></a>
<p><b>Linking Exceptions</b><br>
<blockquote><a name="177880"></a>
During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution documented in <a href="ConstantPool.doc.html#86899">Section 5.4.3.3</a> can be thrown.</blockquote><p>
<blockquote><a name="437466"></a>
Otherwise, if the resolved method is an instance initialization method, and the class in which it is declared is not the class symbolically referenced by the instruction, a <code>NoSuchMethodError</code> is thrown.</blockquote><p>
<blockquote><a name="68877"></a>
Otherwise, if the resolved method is a class (<code>static</code>) method, the <i>invokespecial</i> instruction throws an <code>IncompatibleClassChangeError</code>.</blockquote><p>
<blockquote><a name="311447"></a>
Otherwise, if no method matching the resolved name and descriptor is selected, <i>invokespecial</i> throws an <code>AbstractMethodError</code>.</blockquote><p>
<blockquote><a name="210995"></a>
Otherwise, if the selected method is <code>abstract</code>, <i>invokespecial</i> throws an <code>AbstractMethodError</code>.</blockquote><p>

<a name="invokespecial.Runtime"></a>
<p><b>Runtime Exceptions</b><br>
<blockquote><a name="442232"></a>
Otherwise, if <i>objectref</i> is <code>null</code>, the <i>invokespecial</i> instruction throws a <code>NullPointerException</code>.</blockquote><p>
<blockquote><a name="442233"></a>
Otherwise, if the selected method is <code>native</code> and the code that implements the method cannot be bound, <i>invokespecial</i> throws an <code>UnsatisfiedLinkError</code>.</blockquote><p>
<a name="invokespecial.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="68888"></a>
The difference between the <i>invokespecial</i> and the <i>invokevirtual</i> instructions is that <i>invokevirtual</i> invokes a method based on the class of the object. The <i>invokespecial</i> instruction is used to invoke instance initialization methods <a href="Overview.doc.html#12174">(&#167;3.9)</a> as well as <code>private</code> methods and methods of a superclass of the current class. </blockquote><p>
<blockquote><a name="68890"></a>
The <i>invokespecial</i> instruction was named <i>invokenonvirtual</i> prior to Sun's JDK release 1.0.2.</blockquote><p>
<blockquote><a name="448025"></a>
The <i>nargs</i> argument values and <i>objectref</i> are not one-to-one with the first <i>nargs</i> + <i>1</i> local variables. Argument values of types <code>long</code> and <code>double</code> must be stored in two consecutive local variables, thus more than <i>nargs</i> local variables may be required to pass <i>nargs</i> argument values to the invoked method.</blockquote><p>
<blockquote><a name="448022"></a>
</blockquote><p>

<a name="invokestatic"></a>
<hr><h2>invokestatic</h2>
<a name="invokestatic.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68901"></a>
Invoke a class (<code>static</code>) method<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68896"></a>
 <i>invokestatic</i>
<td><a name="87568"></a>
 

<tr><td><a name="68898"></a>
 <i>indexbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="68900"></a>
 <i>indexbyte2</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="invokestatic.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68902"></a>
<i>invokestatic</i> = 184 (0xb8)</blockquote><p>
<a name="invokestatic.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68903"></a>
...<em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="invokestatic.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="475919"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the runtime constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The runtime constant pool item at that index must be a symbolic reference to a method <a href="ConstantPool.doc.html#73272">(&#167;5.1)</a>, which gives the name and descriptor <a href="ClassFile.doc.html#7035">(&#167;4.3.3)</a> of the method as well as a symbolic reference to the class in which the method is to be found. The named method is resolved <a href="ConstantPool.doc.html#86899">(&#167;5.4.3.3)</a>. The method must not be the class or interface initialization method <a href="Overview.doc.html#12174">(&#167;3.9)</a>. It must be <code>static</code>, and therefore cannot be <code>abstract</code>. </blockquote><p>
<blockquote><a name="422204"></a>
On successful resolution of the method, the class that declared the resolved field is initialized <a href="ConstantPool.doc.html#77976">(&#167;5.5)</a> if that class has not already been initialized.</blockquote><p>
<blockquote><a name="238878"></a>
The operand stack must contain <i>nargs</i> argument values, where the number, type, and order of the values must be consistent with the descriptor of the resolved method.</blockquote><p>
<blockquote><a name="240701"></a>
If the method is <code>synchronized</code>, the monitor associated with the resolved class is acquired or reentered.</blockquote><p>

<blockquote><a name="447990"></a>
If the method is not <code>native</code>, the <i>nargs </i>argument values are popped from the operand stack. A new frame is created on the Java virtual machine stack for the method being invoked. The <i>nargs</i> argument values are consecutively made the values of local variables of the new frame, with <i>arg1</i> in local variable <i>0</i> (or, if <i>arg1</i> is of type <code>long</code> or <code>double</code>, in local variables <i>0</i> and <i>1</i>) and so on. Any argument value that is of a floating-point type undergoes value set conversion <a href="Overview.doc.html#33120">(&#167;3.8.3)</a> prior to being stored in a local variable. The new frame is then made current, and the Java virtual machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.</blockquote><p>
<blockquote><a name="327007"></a>
If the method is <code>native</code> and the platform-dependent code that implements it has not yet been bound <a href="ConstantPool.doc.html#74727">(&#167;5.6)</a> into the Java virtual machine, that is done. The <i>nargs</i> argument values are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion <a href="Overview.doc.html#33120">(&#167;3.8.3)</a> prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns, the following take place:</blockquote><p>
<ul><li>If the <code>native</code> method is <code>synchronized</code>, the monitor associated with the resolved class is released or exited as if by execution of a <i>monitorexit</i> instruction. <p>
<li>If the <code>native</code> method returns a value, the return value of the  platform-dependent code is converted in an implementation-dependent way to the return type of the <code>native</code> method and pushed onto the operand stack.
</ul><a name="invokestatic.Linking"></a>
<p><b>Linking Exceptions</b><br>
<blockquote><a name="327014"></a>
During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution documented in <a href="ConstantPool.doc.html#86899">Section 5.4.3.3</a> can be thrown.</blockquote><p>

<blockquote><a name="444128"></a>
Otherwise, if the resolved method is an instance method, the <i>invokestatic</i> instruction throws an <code>IncompatibleClassChangeError</code>.</blockquote><p>
<a name="invokestatic.Runtime"></a>
<p><b>Runtime Exceptions</b><br>
<blockquote><a name="398081"></a>
Otherwise, if execution of this <i>invokestatic</i> instruction causes initialization of the referenced class, <i>invokestatic</i> may throw an <code>Error</code> as detailed in <a href="Concepts.doc.html#24237">Section 2.17.5</a>.</blockquote><p>
<blockquote><a name="399892"></a>
Otherwise, if the resolved method is <code>native</code> and the code that implements the method cannot be bound, <i>invokestatic</i> throws an <code>UnsatisfiedLinkError</code>.</blockquote><p>
<a name="invokestatic.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="448011"></a>
The <i>nargs</i> argument values are not one-to-one with the first <i>nargs</i> local variables. Argument values of types <code>long</code> and <code>double</code> must be stored in two consecutive local variables, thus more than <i>nargs</i> local variables may be required to pass <i>nargs</i> argument values to the invoked method.</blockquote><p>

<a name="invokevirtual"></a>
<hr><h2>invokevirtual</h2>
<a name="invokevirtual.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68948"></a>
Invoke instance method; dispatch based on class<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68943"></a>
 <i>invokevirtual</i>
<td><a name="87568"></a>
 

<tr><td><a name="68945"></a>
 <i>indexbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="68947"></a>
 <i>indexbyte2</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="invokevirtual.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68949"></a>
<i>invokevirtual</i> = 182 (0xb6)</blockquote><p>
<a name="invokevirtual.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68950"></a>
...<em>, </em><i>objectref</i><em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="invokevirtual.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="422216"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the runtime constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The runtime constant pool item at that index must be a symbolic reference to a method <a href="ConstantPool.doc.html#73272">(&#167;5.1)</a>, which gives the name and descriptor <a href="ClassFile.doc.html#7035">(&#167;4.3.3)</a> of the method as well as a symbolic reference to the class in which the method is to be found. The named method is resolved <a href="ConstantPool.doc.html#86899">(&#167;5.4.3.3)</a>. The method must not be an instance initialization method <a href="Overview.doc.html#12174">(&#167;3.9)</a> or the class or interface initialization method <a href="Overview.doc.html#12174">(&#167;3.9)</a>. Finally, if the resolved method is <code>protected</code> <a href="ClassFile.doc.html#1513">(&#167;4.6)</a>, and it is either a member of the current class or a member of a superclass of the current class, then the class of <i>objectref</i> must be either the current class or a subclass of the current class.</blockquote><p>
<blockquote><a name="68951"></a>
Let C<em> </em>be the class of <em>objectref</em>. The actual method to be invoked is selected by the following lookup procedure:</blockquote><p>
<ul><li>If C contains a declaration for an instance method with the same name and descriptor as the resolved method, and the resolved method is accessible from C, then this is the method to be invoked, and the lookup procedure terminates.
</ul>
<ul><li>Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C &#32;; the method to be invoked is the result of the recursive invocation of this lookup procedure.<p>
<li>Otherwise, an <code>AbstractMethodError</code> is raised.
</ul><blockquote><a name="68969"></a>
The <i>objectref</i> must be followed on the operand stack by <i>nargs</i> argument values, where the number, type, and order of the values must be consistent with the descriptor of the selected instance method.</blockquote><p>
<blockquote><a name="138096"></a>
If the method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is acquired or reentered.</blockquote><p>
<blockquote><a name="135976"></a>
If the method is not <code>native</code>, the <i>nargs</i> argument values and <i>objectref</i> are popped from the operand stack. A new frame is created on the Java virtual machine stack for the method being invoked. The <i>objectref</i> and the argument values are consecutively made the values of local variables of the new frame, with <i>objectref</i> in local variable <i>0</i>, <i>arg1</i> in local variable <i>1</i> (or, if <i>arg1</i> is of type <code>long</code> or <code>double</code>, in local variables <i>1</i> and <i>2</i>), and so on. Any argument value that is of a floating-point type undergoes value set conversion <a href="Overview.doc.html#33120">(&#167;3.8.3)</a> prior to being stored in a local variable. The new frame is then made current, and the Java virtual machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.</blockquote><p>
<blockquote><a name="498512"></a>
If the method is <code>native</code> and the platform-dependent code that implements it has not yet been bound <a href="ConstantPool.doc.html#74727">(&#167;5.6)</a> into the Java virtual machine, that is done. The <i>nargs</i> argument values and <i>objectref</i> are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion <a href="Overview.doc.html#33120">(&#167;3.8.3)</a> prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns, the following take place:</blockquote><p>

<ul><li>If the <code>native</code> method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is released or exited as if by execution of a <i>monitorexit</i> instruction. <p>
<li>If the <code>native</code> method returns a value, the return value of the  platform-dependent code is converted in an implementation-dependent way to the return type of the <code>native</code> method and pushed onto the operand stack.
</ul><a name="invokevirtual.Linking"></a>
<p><b>Linking Exceptions</b><br>
<blockquote><a name="177874"></a>
During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution documented in <a href="ConstantPool.doc.html#86899">Section 5.4.3.3</a> can be thrown.</blockquote><p>
<blockquote><a name="244681"></a>
Otherwise, if the resolved method is a class (<code>static</code>) method, the <i>invokevirtual</i> instruction throws an <code>IncompatibleClassChangeError</code>.</blockquote><p>
<a name="invokevirtual.Runtime"></a>
<p><b>Runtime Exceptions</b><br>
<blockquote><a name="240778"></a>
Otherwise, if <i>objectref</i> is <code>null</code>, the <i>invokevirtual</i> instruction throws a <code>NullPointerException</code>. </blockquote><p>
<blockquote><a name="240779"></a>
Otherwise, if no method matching the resolved name and descriptor is selected, <i>invokevirtual</i> throws an <code>AbstractMethodError</code>.</blockquote><p>
<blockquote><a name="240781"></a>
Otherwise, if the selected method is <code>abstract</code>, <i>invokevirtual</i> throws an <code>AbstractMethodError</code>.</blockquote><p>
<blockquote><a name="498527"></a>
Otherwise, if the selected method is <code>native</code> and the code that implements the method cannot be bound, <i>invokevirtual</i> throws an <code>UnsatisfiedLinkError</code>.</blockquote><p>
<a name="invokevirtual.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="498530"></a>
The <i>nargs</i> argument values and <i>objectref</i> are not one-to-one with the first <i>nargs</i> + <i>1</i> local variables. Argument values of types <code>long</code> and <code>double</code> must be stored in two consecutive local variables, thus more than <i>nargs</i> local variables may be required to pass <i>nargs</i> argument values to the invoked method.</blockquote><p>

<a name="ior"></a>
<hr><h2>ior</h2>
<a name="ior.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="68994"></a>
Boolean OR <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="68993"></a>
 <i>ior</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="ior.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="68995"></a>
<i>ior</i> = 128 (0x80)</blockquote><p>
<a name="ior.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="68996"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="ior.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="68997"></a>
Both<i> value1</i> and <i>value2</i> must be of type <code>int</code>. They are popped from the operand stack. An <code>int</code> <i>result</i> is calculated by taking the bitwise inclusive OR of <i>value1</i> and <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>

<a name="irem"></a>
<hr><h2>irem</h2>
<a name="irem.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="69007"></a>
Remainder <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="69006"></a>
 <i>irem</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="irem.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="69008"></a>
<i>irem</i> = 112 (0x70)</blockquote><p>
<a name="irem.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="69009"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="irem.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="69010"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. The <code>int</code> <i>result</i> is <i>value1</i> - (<i>value1</i> / <i>value2</i>) * <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<blockquote><a name="69011"></a>
The result of the <i>irem</i> instruction is such that <code>(a</code>/<code>b)*b</code> + <code>(a%b)</code> is equal to <code>a</code>. This identity holds even in the special case in which the dividend is the negative <code>int</code> of largest possible magnitude for its type and the divisor is -<code>1</code> (the remainder is <code>0</code>). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive. Moreover, the magnitude of the result is always less than the magnitude of the divisor. </blockquote><p>
<a name="irem.Runtime"></a>
<p><b>Runtime Exception</b><br>
<blockquote><a name="69013"></a>
If the value of the divisor for an <code>int</code> remainder operator is 0, <i>irem</i> throws an <code>ArithmeticException</code>.</blockquote><p>
<blockquote><a name="69014"></a>
</blockquote><p>

<a name="ireturn"></a>
<hr><h2>ireturn</h2>
<a name="ireturn.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="69024"></a>
Return <code>int</code> from method<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="69023"></a>
 <i>ireturn</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="ireturn.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="69025"></a>
<i>ireturn</i> = 172 (0xac)</blockquote><p>
<a name="ireturn.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="69026"></a>
..., <i>value</i><em> </em><img src="chars/arrwdbrt.gif">  [empty]</blockquote><p>
<a name="ireturn.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="69027"></a>
The current method must have return type <code>boolean</code>, <code>byte</code>, <code>short</code>, <code>char</code>, or <code>int</code>. The <i>value</i> must be of type <code>int</code>. If the current method is a <code>synchronized</code> method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a <i>monitorexit</i> instruction. If no exception is thrown, <i>value</i> is popped from the operand stack of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a> and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.</blockquote><p>
<blockquote><a name="69031"></a>
The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.</blockquote><p>
<a name="ireturn.Runtime"></a>
<p><b>Runtime Exceptions</b><br>
<blockquote><a name="452705"></a>
If the current method is a <code>synchronized</code> method and the current thread is not the owner of the monitor acquired or reentered on invocation of the method, <i>ireturn</i> throws an <code>IllegalMonitorStateException</code>. This can happen, for example, if a <code>synchronized</code> method contains a <i>monitorexit</i> instruction, but no <i>monitorenter</i> instruction, on the object on which the method is synchronized.</blockquote><p>
<blockquote><a name="250743"></a>
Otherwise, if the virtual machine implementation enforces the rules on structured use of locks described in <a href="Threads.doc.html#22500">Section 8.13</a> and if the first of those rules is violated during invocation of the current method, then <i>ireturn</i> throws an <code>IllegalMonitorStateException</code>.</blockquote><p>
<blockquote><a name="250618"></a>
</blockquote><p>

<a name="ishl"></a>
<hr><h2>ishl</h2>
<a name="ishl.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="69041"></a>
Shift left <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="69040"></a>
 <i>ishl</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="ishl.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="69042"></a>
<i>ishl</i> = 120 (0x78)</blockquote><p>
<a name="ishl.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="69043"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="ishl.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="69044"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. An <code>int</code> <i>result</i> is calculated by shifting <i>value1</i> left by <em>s</em> bit positions, where <em>s</em> is the value of the low 5 bits of <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<a name="ishl.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="69045"></a>
This is equivalent (even if overflow occurs) to multiplication by 2 to the power <em>s</em>. The shift distance actually used is always in the range 0 to 31, inclusive, as if <i>value2</i> were subjected to a bitwise logical AND with the mask value 0x1f. </blockquote><p>

<a name="ishr"></a>
<hr><h2>ishr</h2>
<a name="ishr.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="69055"></a>
Arithmetic shift right <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="69054"></a>
 <i>ishr</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="ishr.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="69056"></a>
<i>ishr</i><em> </em>= 122 (0x7a)</blockquote><p>
<a name="ishr.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="69057"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="ishr.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="459238"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. An <code>int</code> <i>result</i> is calculated by shifting <i>value1</i> right by s bit positions, with sign extension, where s is the value of the low 5 bits of <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<a name="ishr.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="69062"></a>
The resulting value is <img src="Instructions2.doc.anc9.gif">, where s is <i>value2</i> &amp; 0x1f. For nonnegative <i>value1</i>, this is equivalent to truncating <code>int</code> division by 2 to the power s. The shift distance actually used is always in the range 0 to 31, inclusive, as if <i>value2</i> were subjected to a bitwise logical AND with the mask value 0x1f.</blockquote><p>

<a name="istore"></a>
<hr><h2>istore</h2>
<a name="istore.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="69071"></a>
Store <code>int</code> into local variable<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="69068"></a>
 <i>istore</i>
<td><a name="87568"></a>
 

<tr><td><a name="69070"></a>
 <i>index</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="istore.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="69072"></a>
<i>istore</i> = 54 (0x36)</blockquote><p>
<a name="istore.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="69073"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="istore.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="69074"></a>
The <i>index</i> is an unsigned byte that must be an index into the local variable array of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The <i>value</i> on the top of the operand stack must be of type <code>int</code>. It is popped from the operand stack, and the value of the local variable at <i>index</i> is set to <i>value</i>.</blockquote><p>
<a name="istore.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="69078"></a>
The <i>istore</i> opcode can be used in conjunction with the <i>wide</i> instruction to access a local variable using a two-byte unsigned index.</blockquote><p>

<a name="istore_n"></a>
<hr><h2>istore_&lt;n&gt;</h2>
<a name="istore_n.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="69088"></a>
Store <code>int</code> into local variable<p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="69087"></a>
 <i>istore_&lt;n&gt;</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="istore_n.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="69089"></a>
<i>istore_0</i> = 59 (0x3b) <i>istore_1</i> = 60 (0x3c) <i>istore_2</i> = 61 (0x3d) <i>istore_3</i> = 62 (0x3e)</blockquote><p>
<a name="istore_n.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="69090"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ...</blockquote><p>
<a name="istore_n.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="69091"></a>
The <i>&lt;n&gt;</i> must be an index into the local variable array of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The <i>value</i> on the top of the operand stack must be of type <code>int</code>. It is popped from the operand stack, and the value of the local variable at <i>&lt;n&gt;</i> is set to <i>value</i>. </blockquote><p>
<a name="istore_n.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="69095"></a>
Each of the <i>istore_&lt;n&gt;</i> instructions is the same as <i>istore</i> with an <i>index</i> of <i>&lt;n&gt;</i>, except that the operand <i>&lt;n&gt;</i> is implicit.</blockquote><p>

<a name="isub"></a>
<hr><h2>isub</h2>
<a name="isub.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="69108"></a>
Subtract <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="69107"></a>
 <i>isub</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="isub.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="69109"></a>
<i>isub</i> = 100 (0x64)</blockquote><p>
<a name="isub.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="69110"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="isub.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="69111"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. The <code>int</code> <i>result</i> is <i>value1</i> - <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<blockquote><a name="69112"></a>
For <code>int</code> subtraction, <code>a</code> - <code>b</code> produces the same result as <code>a</code> + (-<code>b</code>). For <code>int</code> values, subtraction from zero is the same as negation.</blockquote><p>
<blockquote><a name="448556"></a>
The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two's-complement format, represented as a value of type <code>int</code>. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.</blockquote><p>
<blockquote><a name="69113"></a>
Despite the fact that overflow may occur, execution of an <i>isub</i> instruction never throws a runtime exception.</blockquote><p>

<a name="iushr"></a>
<hr><h2>iushr</h2>
<a name="iushr.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="69123"></a>
Logical shift right <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="69122"></a>
 <i>iushr</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="iushr.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="69124"></a>
<i>iushr</i> = 124 (0x7c)</blockquote><p>
<a name="iushr.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="69125"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="iushr.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="69126"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. An <code>int</code> <i>result</i> is calculated by shifting <i>value1</i> right by s bit positions, with zero extension, where s is the value of the low 5 bits of <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>
<a name="iushr.Notes"></a>
<p><b>Notes</b><br>
<blockquote><a name="100222"></a>
If <em>value1</em> is positive and s is <i>value2</i> &amp; 0x1f, the result is the same as that of <i>value1</i> >> s; if <i>value1</i> is negative, the result is equal to the value of the expression (<i>value1</i> >> s) + (2 << ~s). The addition of the (2 << ~s) term cancels out the propagated sign bit. The shift distance actually used is always in the range 0 to 31, inclusive.</blockquote><p>

<a name="ixor"></a>
<hr><h2>ixor</h2>
<a name="ixor.Operation"></a>
<p><b>Operation</b><br>
<blockquote><a name="69144"></a>
Boolean XOR <code>int</code><p><Table Border="1">
</blockquote>

<p><b>Format</b><br>
<blockquote>

<tr><td><a name="69143"></a>
 <i>ixor</i>
<td><a name="87568"></a>
 

</Table><br></blockquote><p>
<a name="ixor.Forms"></a>
<p><b>Forms</b><br>
<blockquote><a name="69145"></a>
<i>ixor</i> = 130 (0x82)</blockquote><p>
<a name="ixor.Operand"></a>
<p><b>Operand Stack</b><br>
<blockquote><a name="69146"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i></blockquote><p>
<a name="ixor.Description"></a>
<p><b>Description</b><br>
<blockquote><a name="69147"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>int</code>. They are popped from the operand stack. An <code>int</code> <i>result</i> is calculated by taking the bitwise exclusive OR of <i>value1</i> and <i>value2</i>. The <i>result</i> is pushed onto the operand stack.</blockquote><p>


<hr>
<!-- This inserts footnotes--><p>
<a href="VMSpecTOC.doc.html">Contents</a> | <a href="Instructions2.doc5.html">Prev</a> | <a href="Instructions2.doc7.html">Next</a> | <a href="VMSpecIX.fm.html">Index</a>
<p>
<font size="-1"><i>The Java</i><sup><font size=-2>TM</font></sup><i> Virtual Machine Specification </i><br>
<!-- HTML generated by Suzette Pelouch on March 30, 1999 -->
<i><a href="Copyright.doc.html">Copyright &#169 1999 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jvm@java.sun.com">jvm@java.sun.com</a>
</font>
</body></html>
